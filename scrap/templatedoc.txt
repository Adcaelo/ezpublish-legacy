The start of the template system is when a client request a template
using a URI, the request normally looks like:
$tpl->fetch( URI )

The URI consist of

RESOURCE:PATH

The RESOURCE part is optional and if omitted it will use the standard
Resource Handler (which is in most cases the plain file handler).
The Resource Handler will be called and it will fetch the template text,
this can involve opening a file and reading it's contens, doing charset
conversion to the internal charset and stripping off certain internal
PHP hints at the top of the file ( {?template charset=utf8 ?} ).
The template text is then sent to the Template Parser.

Resource Handler:
Resource handlers decouples the acquisition of the template text from
the other parts of the template system. In eZ publish it used to
fetch override templates using design keys. The following handlers
are currently in place in eZ publish:

file: (also the default handler) fetches the file from path starting
      from the script CWD.
design: Uses the file: handler to fetch the actual file but will
        figure out the correct file from the current designs,
        design keys and override definitions.
standard: Similar to design: but will only look in the Standard Design.

Standard Design:
The design which will be used as fallback, it contains all the templates
that are used but is in most cases very generic.


Site Design:
The current design on the site, will contain overrides of existing
templates for whather is applicable.


Additional Designs:
A set of the designs that have higher priority than the Standard Design
but lower than the Site Design. A good use of this is to place the Admin
Design as an Additional Design and override the required parts in a
custom Site Design.


Template Parser:
The parser will go trough the template text and generate a tree structure
out of it. The tree structure consists of Template Nodes which represents
either text, variable usage, operator usage or function blocks.

Each Template Node is an array with indexed elements, the first (0) element
is always the Node Type which is a number. The rest of the elements depends
on the type.

The tree will always start with one Template Node which is of type Root which
will contain an array with child Template Nodes. The template system defines
four basic types which are used to process a template. The types are:
1 - Root
2 - Text
3 - Variable elements
4 - Function

However in some cases (such as with template compiling) the tree may contain
some internal nodes (ID 100-999) or user defined nodes( 1000-1999).
Internal nodes are used by the template compiler to transform nodes into
simpler types. User defined types are not supported yet.

The execution of a template is done by passing control over to the root node,
it's then up the code for that node to continue the execution. The root node
will go trough all children an examine the type and do one of the following for:

Root Node:
Process all children as stated above. The result of each child is appended to
the current output text.

Text Node:
Fetch text string and append it to the current output text.

Variable Node:
Go trough all the Variable Elements and fetch their values, this involves
fetching Static Values, Variable Lookup, Attribute Lookup and Operator Processing.
The resulting value will be passed on to the template system for a Value
Inspection.

Function Node:
The execution is passed on the Function Handler with the Function Arguments,
Function Children. What happens then is entirely up to the function. In most
cases this involves processing all children as the Root Node would do it.
It will also usually process some or all of it's arguments to get their values
(the arguments are Variable Elements).




Variable Element:
An array which encapsulates either a Static Value, a Variable Lookup, Attribute Lookup
or an Operator call.


Static Value:
A static value is an internal PHP value which does not require any more processing
or lookup, the following types are possible.
String (PHP string)
Numeric (PHP integer or float)
Identifier (PHP string)


Variable Lookup:
A variable lookup consists of checking for the presence of a variable using a name
and a namespace. If the variable exists the value of the variable will fetched and
returned. A variable lookup is typically done like this:
$this->Variables[$namespace][$name]


Attribute Lookup:
This involves checking for the precense of an attribute by it's name or number on
a value. Attribute lookup is only possible on arrays and objects.
a) array:
   The attribute name/number is used as the array key.
b) object:
   It will check for the presence of a hasAttribute() and attribute() method on
   the object, if it exists it will call hasAttribute() to see if the object
   has the requested attribute. In which case it will call attribute() to get
   the new value. The signature of the methods are:
function hasAttribute( $name )
{
}
function &attribute( $name )
{
}


Operator Processing:
This involves calling the Operator Handler with the last value as the input value
(or null if no last value) and the Operator Parameters. The Operator Handler will
then do whatever it wishes and return a new output value. The Operator Parameters
are Variable Elements.


Operator Handler:
An operator handler is a PHP class which defines certain methods for the template
system to be called, the handler must define the following methods:
operatorList() - Returns array with operator names that the class handles
modify() - The method which does the actual operator processing

The handler may also define one of these methods:
operatorTemplateHints() - Returns an associative array with hints for each
                          operator, the hints are used by the template compiler
                          to perform optimizations.
namedParameterPerOperator() - Returns true or false.
namedParameterList() - If namedParameterPerOperator() is true the value will be an associative array
                       with each operator as key, if not it will be one parameter structure.


Value Inspection:
The type of the value is inspected. If it's an object it will check for one of two things:
1. The precense of a templateValue method, if it exists it calls the method and uses the
    returned value as the current value.
2. The precense of a templateData method, it if exist it calls the method and expects
   an array as a return value. The array must contain:
   'type' => The type (currently only 'template' is supported)

   For 'template' type it will expect these entries.
   'uri' => The name of the template to use for processing.
   'template_variable_name' => The name of the template variable to place the current value.
   It will then set the template variable and fetch the result of the template in 'uri'.
   The resulting text will be used as the current value.






Template compilation:
Compiling a template consists of the following steps:
1. Node transformation, replace bultin nodes with  less general (and mostly less recursive)
   nodes which represents PHP code, variable assignment etc. (See Template Node below).
2. Static optimization, turn Template Operators and Template Functions into static
   values if possible (e.g true() becomes the PHP value true).
3. Node combining, this will turn multiple adjacent static nodes (Is often a result of
   the Static Optimization step) into one entry.
4. Generate PHP code from the resulting nodes.




******************************************************
* Template node transformation
******************************************************


Variable Node:


Template code:
{-5|abs}

Internal Variable Element structure:
array(
  array( 2, -5 ),
  array( 6,
    array( 'abs' ) ) )

Possible transformed structure:
array(
  array( 2, 5 ) )

Template code:
{$a|abs}

Internal Variable Element structure:
array(
  array( 4, array( false, 3, 'a' ) ),
  array( 6,
    array( 'abs' ) ) )

Possible transformed structure:
array(
  array( 4, array( false, 3, 'a' ) ),
  array( 101,
         '%output% = abs( %input% );',
         false ) )

Template code:
{sum( $a, $b )}

Internal Variable Element structure:
array(
  array( 6,
    array( 'sum'
      array( array( 4, array( false, 3, 'a' ) ) ),
      array( array( 4, array( false, 3, 'b' ) ) ) ) ) )

Possible transformed structure:
array(
  array( 101,
         '%output% = %1% + %2%;',
         false,
         array( array( array( 4, array( false, 3, 'a' ) ) ), // %1%
                array( array( 4, array( false, 3, 'b' ) ) )  // %2%
              )
       ) )


Template code:
{array( 1, 2, 5 ).1}

Internal Variable Element structure:
array(
  array( 6,
    array( 'array'
      array( array( 2, 1 ) ),
      array( array( 2, 2 ) ),
      array( array( 2, 5 ) ) ) ),
  array( 5,
         array( array( 2, 1 ) ) ) )

Template code:
{max( min( $a, $b ), sum( $c, $d ) )}


Internal Variable Element structure:
array(
  array( 6,
    array( 'max',
      array( array( 6,
               array( 'min',
                 array( array( 4,
                          array( false, 3, 'a' ) ) ),
                 array( array( 4,
                          array( false, 3, 'b' ) ) ) ) ) )
      array( array( 6,
               array( 'sum',
                 array( array( 4,
                          array( false, 3, 'c' ) ) ),
                 array( array( 4,
                          array( false, 3, 'd' ) ) ) ) ) ) ) ) )



******************************************************
* Template node definitions
******************************************************

Template Node:
0 - Node Type
1 - Children (Only for some Types)
2 - Data (Depends on type)
3 - Placement (array or false)

example
array(
0 => 2,
1 => false,
2 => 'Some text',
3 => array( array( 1, 0 ),
            array( 1, 9 ),
            'test.tpl' ) )

Template Node Types:
1 - Root
2 - Text
3 - Variable
4 - Function

100 - Internal (Not used, only used as starting value)
101 - Code piece (Custom PHP code)
102 - Variable unset (Unsetting of a variable)
103 - Namespace change (Changing the namespace)
104 - Namespace restore (Restoring the namespace)
105 - Variable set (Changing a variable)
120 - Warning
121 - Error
140 - Resource Acquisition

1000 - Custom type (From 1001 and up user specific types can be added)

Root Node:
1 - Children (array of Template Nodes)

Text Node:
1 - false
2 - String or false if no data
3 - Placement (array or false)

Variable Node:
1 - Name of variable to put variable result in, or false to print it out
2 - Array of Variable Elements
3 - Placement (array or false)
4 - Parameters (array, is optional)

Function Node:
1 - Children (array of Template Nodes)
2 - Function name
3 - Parameters (associative array of Variable Nodes)
4 - Placement (array or false)

Code Piece Node:
1 - PHP code in a string
2 - Parameters

Variable Set Node:
1 - Name of variable
2 - Value
3 - Parameters

Variable Unset Node:
1 - Name of variable
2 - Parameters

Warning Node:
1 - Warning text
2 - Warning label
3 - Parameters

Error Node:
1 - Error text
2 - Error label
3 - Parameters

Resource Acquisition Node
1 - Resource Name
2 - Template Name
3 - File Name
4 - Method
5 - Extra Parameters (array or false)
6 - Placement Array
7 - Parameters
8 - New rootnamespace

******************************************************
* Variable element definitions
******************************************************

Variable Elements:
An array with Variable Element entries, each entry is processed after
the other. It is common for the first entry to be of type
String, Numeric, Identifier or Variable.
array( el1, el2, el3, ... )


Variable Element:
0 - Type
1 - Variable data (Depends on type)
2 - Placement (array or false)

Variable Element Types:
0 - Void (Used to nullify entries, normally not used)
1 - String (string in Variable data)
2 - Numeric (int or float, value in Variable data)
3 - Identifier (string in Variable data, most of the time this is similar to String)
4 - Variable (Variable data is an array)
5 - Attribute (Variable data is an array with Variable Elements)
6 - Operator (Variable data is an array)

100 - Internal (Not used, only used as starting value)
101 - Code piece (Custom PHP code)
//102 - Variable unset (Unsetting of a variable)
//103 - Namespace change (Changing the namespace)
//104 - Namespace restore (Restoring the namespace)
//105 - Variable set (Changing a variable)
120 - Warning
121 - Error

Code Piece Element:
0 - 101
1 - PHP code with %% markers, %input% is the input value or variable,
    %output% is the output variable.
2 - Placement
3 - Array of sub Variable Elements,
    each element will be processed before the code and placed
    in variables. The first entry will be %1%, the second %2% etc.
    Is optional so it might be omitted.

String Element Type:
Example:
"some string"
array( 1, 'some string', array( ... ) )

Numeric Element Type:
Example:
42
array( 2, 42, array( ... ) )

Identifier Element Type:
Example:
my_identifier
array( 3, 'my_identifier', array( ... ) )

Variable Element Type Data array:
0 - Namespace name
1 - Namespace scope (root (2), global (1) or current (3))
2 - Variable name


Attribute Element Type Data array:
The array consist of multiple Variable Elements.
Example:
.name
array( array( 3, 'name', array( ... ) ) )

Operator Element Type Data array:
0 - Operator name (string)
1 and up (Parameters, each is a Variable Element array)


Placement Array:
0 - Start (Position array)
1 - Stop (Position array)
3 - Template name (full path)


Position Array:
0 - Line number (starts at 1)
1 - Column number (starts at 0)
2 - Offset in file
